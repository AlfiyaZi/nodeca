IO
==

All realtime communication needs are providen by `nodeca.io` module, which
provides following methods:

- **nodeca.io.subscribe**(channel, handler)
- **nodeca.io.unsubscribe**(channel[, handler])
- **nodeca.io.publish**(channel, message)
- **nodeca.io.api3**(data, options, callback)



Usage examples
--------------

``` javascript
//
// subscibing to messages from the channel
nodeca.io.subscribe('/foo/bar', function handler(message) { /* ... */  })
  .done(function () { /* ... subscribed ... */ })
  .fail(function () { /* ... subscription failed ... */ });
});


//
// unsubscibing to messages from the channel
nodeca.io.unsubscribe('/foo/bar', handler)
  .done(function () { /* ... unsubscribed ... */ })
  .fail(function () { /* ... unsubscription failed ... */ });
});


//
// publishing to messages from the channel
nodeca.io.publish('/foo/bar', message)
  .done(function () { /* ... published ... */ })
  .fail(function () { /* ... publishing failed ... */ });
});
```


API tree calls in details
-------------------------

We provide two secret channels for request/response in format:

- `/x/<secret>/api3-req` - channel for requests
- `/x/<secret>/api3-res` - channel for responses

Secret is a random 128 bit crypto-strong string. Clients are allowed to
supscribe to _response_ and publish to _request_ channels only.


#### Communication protocol

Client sends a message to the _requests_ channel with following structure:

    id:           <Number>    Request ID. Generated by client.
    msg:
      version:    <String>    Application version.
      method:     <String>    Server method name. E.g. 'nodeca.server.foobar'
      params:     <Mixed>     Parameters object given to `nodeca.server.*` method.

Once server executed request it will publish a message to the _responses_
channel with following structure:

    id:           <Number>    Original request ID.
    msg:
      version:    <String>    Application version.
      error:      <String>    An error if any.
      result:     <Mixed>     Server response.
